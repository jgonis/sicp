(define-library (concabs fungraph)
  (export make-image
	  image?
	  image-width
	  image-height
	  save-image-as-epsf
	  line
	  filled-triangle
	  stack
	  resize-image
	  overlay
	  invert
	  mirror-image
	  quarter-turn-right
	  quarter-turn-left
	  half-turn
	  side-by-side
	  ps-image)
  (import (scheme base)
	  (scheme write)
	  (scheme file))
  (begin
    (define default-image-size 100)
    
    (define-record-type <image>
      (make-image image-proc width height)
      image?
      (width image-width)
      (height image-height)
      (image-proc image-proc))

    ;;(save-image-as-epsf (line -1 -1 1 1) "line.eps")
    (define save-image-as-epsf
      (let ((left-margin 50)       ; margins make printing work better
            (bottom-margin 50))
	(lambda (image filename)
	  (if (not (image? image))
              (error "argument to save-image-as-epsf not an image" image))
	  (with-output-to-file filename
            (lambda ()
              (display "%!PS-Adobe-3.0 EPSF-3.0")
              (newline)
              (display "%%BoundingBox: ")
              (display left-margin)
              (display " ")
              (display bottom-margin)
              (display " ")
              (display (+ left-margin (image-width image)))
              (display " ")
              (display (+ bottom-margin (image-height image)))
              (newline)
              ((image-proc image)
               (lambda (x y) (+ (* (+ x 1) (image-width image) .5)
				left-margin))
               (lambda (x y) (+ (* (+ y 1) (image-height image) .5)
				bottom-margin)))
              (newline)
              (display "showpage")
              (newline))))))

    (define (ps-image ps . wh) ; makes an image from a PostScript string
      (if (not (string? ps))
	  (error "argument not a string in ps-image" ps))
      (let ((width default-image-size)
            (height default-image-size))
	(if (not (null? wh))
            (begin (set! width (car wh))
		   (if (not (null? (cdr wh)))
                       (begin (set! height (cadr wh))
                              (if (not (null? (cddr wh)))
				  (error "too many argument to ps-image")))
                       (set! height width))))
	(if (not (and (integer? height)
                      (integer? width)
                      (exact? height)
                      (exact? width)
                      (> height 0)
                      (> width 0)))
            (error "illegal size specification in ps-image" wh))
	(make-image (lambda (xt yt)
                      (let* ((tx (xt 0 0))
                             (ty (yt 0 0))
                             (x->x (- (xt 1 0) tx))
                             (x->y (- (yt 1 0) ty))
                             (y->x (- (xt 0 1) tx))
                             (y->y (- (yt 0 1) ty)))
			(newline)
			(display "save [")
			(display (inexact x->x))
			(display " ")
			(display (inexact x->y))
			(display " ")
			(display (inexact y->x))
			(display " ")
			(display (inexact y->y))
			(display " ")
			(display (inexact tx))
			(display " ")
			(display (inexact ty))
			(display "] concat ")
			(display ps)
			(display " restore")
			(newline)))
                    width
		    height)))

    (define (quarter-turn-right image)
      (if (not (image? image))
	  (error "argument to quarter-turn-right not an image" image))
      (make-image (lambda (xt yt)
                    ((image-proc image) (lambda (x y) (xt y (- x)))
                     (lambda (x y) (yt y (- x)))))
		  (image-height image)
		  (image-width image)))

    (define (half-turn image)
      (if (not (image? image))
	  (error "argument to half-turn not an image" image))
      (quarter-turn-right (quarter-turn-right image)))

    (define (quarter-turn-left image)
      (if (not (image? image))
	  (error "argument to quarter-turn-left not an image" image))
      (quarter-turn-right (quarter-turn-right (quarter-turn-right image))))

    (define (side-by-side left-image right-image)
      (if (not (image? left-image))
	  (error "left-image argument to side-by-side not an image" left-image))
      (if (not (image? right-image))
	  (error "right-image argument to side-by-side not an image" right-image))
      (quarter-turn-right (stack (quarter-turn-left right-image) (quarter-turn-left left-image))))
	
    (define (mirror-image image)
      (if (not (image? image))
	  (error "argument to mirror-image not an image" image))
      (make-image (lambda (xt yt)
                    ((image-proc image) (lambda (x y) (xt (- x) y))
                     (lambda (x y) (yt (- x) y))))
		  (image-width image)
		  (image-height image)))

    (define (invert image)
      (if (not (image? image))
	  (error "argument to invert not an image" image))
      (make-image (lambda (xt yt)
                    (let ((x0 (string-append (number->string
                                              (inexact (xt -1 -1)))
                                             " "))
			  (y0 (string-append (number->string
                                              (inexact (yt -1 -1)))
                                             " "))
			  (x1 (string-append (number->string
                                              (inexact (xt 1 1)))
                                             " "))
			  (y1 (string-append (number->string
                                              (inexact (yt 1 1)))
                                             " ")))
                      (newline)
                      (display "newpath ")
                      (display x0)
                      (display y0)
                      (display "moveto ")
                      (display x0)
                      (display y1)
                      (display "lineto ")
                      (display x1)
                      (display y1)
                      (display "lineto ")
                      (display x1)
                      (display y0)
                      (display "lineto closepath fill gsave 1 currentgray sub setgray")
                      ((image-proc image) xt yt)
                      (display "grestore")
                      (newline)))
		  (image-width image)
		  (image-height image)))

    (define (overlay image . images)
      (if (not (image? image))
	  (error "argument to overlay not an image" image))
      (let ((w (image-width image))
            (h (image-height image)))
	(for-each
	 (lambda (i)
	   (if (not (image? i))
               (error "argument to overlay not an image" i))
	   (if (not (and (= (image-width i) w)
			 (= (image-height i) h)))
               (error "Only images of equal size can be overlayed"
                      (cons image images))))
	 images)
	(make-image
	 (lambda (xt yt)
	   (for-each
            (lambda (image) ((image-proc image) xt yt))
            (cons image images)))
	 w h)))

    (define (resize-image image . wh)
      (if (not (image? image))
	  (error "argument to resize-image not an image" image))
      (let ((width default-image-size)
            (height default-image-size))
	(if (not (null? wh))
            (begin (set! width (car wh))
		   (if (not (null? (cdr wh)))
                       (begin (set! height (cadr wh))
                              (if (not (null? (cddr wh)))
				  (error "too many argument to resize-image")))
                       (set! height width))))
	(if (not (and (integer? height)
                      (integer? width)
                      (exact? height)
                      (exact? width)
                      (> height 0)
                      (> width 0)))
            (error "illegal size specification in resize-image" wh))
	(make-image (image-proc image) width height)))

    (define (stack top . rest)
      (define (stack2 top bottom)
	(if (not (image? top))
            (error "argument to stack not an image" top))
	(if (not (image? bottom))
            (error "argument to stack not an image" bottom))
	(if (not (= (image-width top) (image-width bottom)))
            (error "Attempt to stack images of different widths" (list top bottom))
            (let ((th (image-height top))
		  (bh (image-height bottom)))
              (let* ((h (+ th bh))
                     (inexact-h (inexact h)))
		(let ((tscale (/ th inexact-h))
                      (bscale (/ bh inexact-h)))
		  (make-image
		   (lambda (xt yt)
                     ((image-proc top) (lambda (x y)
					 (xt x (+ (* tscale y) bscale)))
                      (lambda (x y)
                        (yt x (+ (* tscale y) bscale))))
                     ((image-proc bottom) (lambda (x y)
                                            (xt x (- (* bscale y) tscale)))
                      (lambda (x y)
                        (yt x (- (* bscale y) tscale)))))
		   (image-width top)
		   h))))))
      (let loop ((image top)
		 (images rest))
	(if (null? images)
            image
            (loop (stack2 image (car images)) (cdr images)))))

    (define (filled-triangle x0 y0 x1 y1 x2 y2 . wh)
      (if (not (real? x0))
	  (error "x0 argument to filled-triangle not a real" x0))
      (if (not (<= -1 x0 1))
	  (error "x0 argument to filled-triangle not in -1 to 1 range" x0))
      (if (not (real? x1))
	  (error "x1 argument to filled-triangle not a real" x1))
      (if (not (<= -1 x1 1))
	  (error "x1 argument to filled-triangle not in -1 to 1 range" x1))
      (if (not (real? x2))
	  (error "x2 argument to filled-triangle not a real" x2))
      (if (not (<= -1 x2 1))
	  (error "x2 argument to filled-triangle not in -1 to 1 range" x2))
      (if (not (real? y0))
	  (error "y0 argument to filled-triangle not a real" y0))
      (if (not (<= -1 y0 1))
	  (error "y0 argument to filled-triangle not in -1 to 1 range" y0))
      (if (not (real? y1))
	  (error "y1 argument to filled-triangle not a real" y1))
      (if (not (<= -1 y1 1))
	  (error "y1 argument to filled-triangle not in -1 to 1 range" y1))
      (if (not (real? y2))
	  (error "y2 argument to filled-triangle not a real" y2))
      (if (not (<= -1 y2 1))
	  (error "y2 argument to filled-triangle not in -1 to 1 range" y2))
      (let ((width default-image-size)
            (height default-image-size))
	(if (not (null? wh))
            (begin (set! width (car wh))
		   (if (not (null? (cdr wh)))
                       (begin (set! height (cadr wh))
                              (if (not (null? (cddr wh)))
				  (error "too many argument to filled-triangle")))
                       (set! height width))))
	(if (not (and (integer? height)
                      (integer? width)
                      (exact? height)
                      (exact? width)
                      (> height 0)
                      (> width 0)))
            (error "illegal size specification in filled-triangle" wh))
	(ps-image (string-append (number->string (inexact x0))
				 " " (number->string (inexact y0))
				 " moveto "
				 (number->string (inexact x1))
				 " " (number->string (inexact y1))
				 " lineto "
				 (number->string (inexact x2))
				 " " (number->string (inexact y2))
				 " lineto closepath fill")
		  width height)))

    (define check-if-arg-is-real
      (lambda (arg arg-name func-name)
	(if (not (real? arg))
	    (error (string-append arg-name " argument to " func-name " is not a real") arg))))

    (define (line x0 y0 x1 y1 . wh)
      (if (not (real? x0))
	  (error "x0 argument to line not a real" x0))
      (if (not (real? x1))
	  (error "x1 argument to line not a real" x1))
      (if (not (real? y0))
	  (error "y0 argument to line not a real" y0))
      (if (not (real? y1))
	  (error "y1 argument to line not a real" y1))
      (let ((width default-image-size)
            (height default-image-size))
	(if (not (null? wh))
            (begin (set! width (car wh))
		   (if (not (null? (cdr wh)))
                       (begin (set! height (cadr wh))
                              (if (not (null? (cddr wh)))
				  (error "too many argument to line")))
                       (set! height width))))
	(if (not (and (integer? height)
                      (integer? width)
                      (exact? height)
                      (exact? width)
                      (> height 0)
                      (> width 0)))
            (error "illegal size specification in line" wh))
	(make-image (lambda (x-transformer y-transformer)
                      (newline)
                      (display "newpath ")
                      (display (inexact (x-transformer x0 y0)))
                      (display " ")
                      (display (inexact (y-transformer x0 y0)))
                      (display " moveto ")
                      (display (inexact (x-transformer x1 y1)))
                      (display " ")
                      (display (inexact (y-transformer x1 y1)))
                      (display " lineto stroke")
                      (newline))
                    width height)))
    ))


